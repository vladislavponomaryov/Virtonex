
        /**
         * Silicon | Multipurpose Bootstrap 5 Template & UI Kit
         * Copyright 2023 Createx Studio
         * Theme core scripts
         *
         * @author Createx Studio
         * @version 1.5.0
         */
        
(function () {
  'use strict';

  /**
   * Theme Mode Switch
   * Switch betwen light/dark mode. The chosen mode is saved to browser's local storage
  */

  const themeModeSwitch = (() => {

    let modeSwitch = document.querySelector('[data-bs-toggle="mode"]');
    
    if(modeSwitch === null) return;

    let checkbox = modeSwitch.querySelector('.form-check-input');

    if (mode === 'dark') {
      root.classList.add('dark-mode');
      checkbox.checked = true;
    } else {
      root.classList.remove('dark-mode');
      checkbox.checked = false;
    }

    modeSwitch.addEventListener('click', (e) => {
      if (checkbox.checked) {
        root.classList.add('dark-mode');
        window.localStorage.setItem('mode', 'dark');
      } else {
        root.classList.remove('dark-mode');
        window.localStorage.setItem('mode', 'light');
      }
    });

  })();

  /**
   * Sticky Navbar
   * Enable sticky behavior of navigation bar on page scroll
  */

  const stickyNavbar = (() => {

    let navbar = document.querySelector('.navbar-sticky');

    if (navbar == null) return;

    let navbarClass = navbar.classList,
        navbarH = navbar.offsetHeight,
        scrollOffset = 500;

    if (navbarClass.contains('position-absolute')) {
      window.addEventListener('scroll', (e) => {
        if (e.currentTarget.pageYOffset > scrollOffset) {
          navbar.classList.add('navbar-stuck');
        } else {
          navbar.classList.remove('navbar-stuck');
        }
      });
    } else {
      window.addEventListener('scroll', (e) => {
        if (e.currentTarget.pageYOffset > scrollOffset) {
          document.body.style.paddingTop = navbarH + 'px';
          navbar.classList.add('navbar-stuck');
        } else {
          document.body.style.paddingTop = '';
          navbar.classList.remove('navbar-stuck');
        }
      });
    }

  })();

  /**
   * Anchor smooth scrolling
   * @requires https://github.com/cferdinandi/smooth-scroll/
  */

  const smoothScroll = (() => {

    let selector = '[data-scroll]',
    fixedHeader = '[data-scroll-header]',
    scroll = new SmoothScroll(selector, {
      speed: 800,
      speedAsDuration: true,
      offset: (anchor, toggle) => {
        return toggle.dataset.scrollOffset || 40;
      },
      header: fixedHeader,
      updateURL: false
    });

  })();

  /**
   * Animate scroll to top button in/off view
  */

  const scrollTopButton = (() => {

    let element = document.querySelector('.btn-scroll-top'),
        scrollOffset = 600;
    
    if (element == null) return;

    let offsetFromTop = parseInt(scrollOffset, 10);
    
    window.addEventListener('scroll', (e) => {
      if (e.currentTarget.pageYOffset > offsetFromTop) {
        element.classList.add('show');
      } else {
        element.classList.remove('show');
      }
    });
  })();

  /**
   * Toggling password visibility in password input
  */

  const passwordVisibilityToggle = (() => {

    let elements = document.querySelectorAll('.password-toggle');

    for (let i = 0; i < elements.length; i++) {
      let passInput = elements[i].querySelector('.form-control'),
      passToggle = elements[i].querySelector('.password-toggle-btn');

      passToggle.addEventListener('click', (e) => {
        
        if (e.target.type !== 'checkbox') return;
        if (e.target.checked) {
          passInput.type = 'text';
        } else {
          passInput.type = 'password';
        }

      }, false);
    }
  })();

  /**
   * Element parallax effect
   * @requires https://github.com/dixonandmoe/rellax
  */

  const elementParallax = (() => {
    const el = document.querySelector('.rellax');

    if (el === null) return;

    const rellax = new Rellax('.rellax', {
      horizontal: true
    });

  })();

  /**
   * Mouse move parallax effect
   * @requires https://github.com/wagerfield/parallax
  */

  const parallax = (() => {

    let element = document.querySelectorAll('.parallax');

    for (let i = 0; i < element.length; i++) {
      let parallaxInstance = new Parallax(element[i]);
    }

  })();

  /**
   * Content carousel with extensive options to control behaviour and appearance
   * @requires https://github.com/nolimits4web/swiper
  */

  const carousel = (() => {

    // forEach function
    let forEach = (array, callback, scope) => {
      for (let i = 0; i < array.length; i++) {
        callback.call(scope, i, array[i]); // passes back stuff we need
      }
    };

    // Carousel initialisation
    let carousels = document.querySelectorAll('.swiper');
    forEach(carousels, (index, value) => {
      
      let userOptions,
          pagerOptions;
      if(value.dataset.swiperOptions != undefined) userOptions = JSON.parse(value.dataset.swiperOptions);


      // Pager
      if(userOptions.pager) {
        pagerOptions = {
          pagination: {
            el: '.pagination .list-unstyled',
            clickable: true,
            bulletActiveClass: 'active',
            bulletClass: 'page-item',
            renderBullet: function (index, className) {
              return '<li class="' + className + '"><a href="#" class="page-link btn-icon btn-sm">' + (index + 1) + '</a></li>';
            }
          }
        };
      }

      // Slider init
      let options = {...userOptions, ...pagerOptions};
      let swiper = new Swiper(value, options);


      // Tabs (linked content)
      if(userOptions.tabs) {

        swiper.on('activeIndexChange', (e) => {
          let targetTab = document.querySelector(e.slides[e.activeIndex].dataset.swiperTab),
              previousTab = document.querySelector(e.slides[e.previousIndex].dataset.swiperTab);

          previousTab.classList.remove('active');
          targetTab.classList.add('active');
        });
      }

    });

  })();

  /**
   * Gallery like styled lightbox component for presenting various types of media
   * @requires https://github.com/sachinchoolur/lightGallery
  */

  const gallery = (() => {

    let gallery = document.querySelectorAll('.gallery');

    if (gallery.length) {
      for (let i = 0; i < gallery.length; i++) {

        const thumbnails = gallery[i].dataset.thumbnails ? true : false,
              video = gallery[i].dataset.video ? true : false,
              defaultPlugins = [lgZoom, lgFullscreen],
              videoPlugin = video ? [lgVideo] : [],
              thumbnailPlugin = thumbnails ? [lgThumbnail] : [],
              plugins = [...defaultPlugins, ...videoPlugin, ...thumbnailPlugin];

        lightGallery(gallery[i], {
          selector: '.gallery-item',
          plugins: plugins,
          licenseKey: 'D4194FDD-48924833-A54AECA3-D6F8E646',
          download: false,
          autoplayVideoOnSlide: true,
          zoomFromOrigin: false,
          youtubePlayerParams: {
            modestbranding: 1,
            showinfo: 0,
            rel: 0
          },
          vimeoPlayerParams: {
            byline: 0,
            portrait: 0,
            color: '6366f1'
          }
        });
      }
    }
  })();

  /**
   * Range slider
   * @requires https://github.com/leongersen/noUiSlider
  */

  const rangeSlider = (() => {

    let rangeSliderWidget = document.querySelectorAll('.range-slider');

    for (let i = 0; i < rangeSliderWidget.length; i++) {

      let rangeSlider = rangeSliderWidget[i].querySelector('.range-slider-ui'),
          valueMinInput = rangeSliderWidget[i].querySelector('.range-slider-value-min'),
          valueMaxInput = rangeSliderWidget[i].querySelector('.range-slider-value-max');

      let options = {
        dataStartMin: parseInt(rangeSliderWidget[i].dataset.startMin, 10),
        dataStartMax: parseInt(rangeSliderWidget[i].dataset.startMax, 10),
        dataMin: parseInt(rangeSliderWidget[i].dataset.min, 10),
        dataMax: parseInt(rangeSliderWidget[i].dataset.max, 10),
        dataStep: parseInt(rangeSliderWidget[i].dataset.step, 10),
        dataPips: rangeSliderWidget[i].dataset.pips
      };

      let start = (options.dataStartMax) ? [options.dataStartMin, options.dataStartMax] : [options.dataStartMin],
          connect = (options.dataStartMax) ? true : 'lower';

      noUiSlider.create(rangeSlider, {
        start: start,
        connect: connect,
        step: options.dataStep,
        pips: options.dataPips ? {mode: 'count', values: 5} : false,
        tooltips: true,
        range: {
          'min': options.dataMin,
          'max': options.dataMax
        },
        format: {
          to: function (value) {
            return '$' + parseInt(value, 10);
          },
          from: function (value) {
            return Number(value);
          }
        }
      });

      rangeSlider.noUiSlider.on('update', (values, handle) => {
        let value = values[handle];
        value = value.replace(/\D/g,'');
        if (handle) {
          if (valueMaxInput) {
            valueMaxInput.value = Math.round(value);
          }
        } else {
          if (valueMinInput) {
            valueMinInput.value = Math.round(value);
          }
        }
      });
      
      if (valueMinInput) {
        valueMinInput.addEventListener('change', function() {
          rangeSlider.noUiSlider.set([this.value, null]);
        });
      }

      if (valueMaxInput) {
        valueMaxInput.addEventListener('change', function() {
          rangeSlider.noUiSlider.set([null, this.value]);
        });
      }
    }

  })();

  /**
   * Form validation
   */

  const formValidation = (() => {
  	const selector = 'needs-validation';

  	window.addEventListener(
  		'load',
  		() => {
  			// Fetch all the forms we want to apply custom Bootstrap validation styles to
  			let forms = document.getElementsByClassName(selector);
  			// Loop over them and prevent submission
  			let validation = Array.prototype.filter.call(forms, form => {
  				form.addEventListener(
  					'submit',
  					e => {
  						if (form.checkValidity() === false) {
  							e.preventDefault();
  							e.stopPropagation();
  						}
  						form.classList.add('was-validated');
  						tabValidation(e);
  					},
  					false
  				);
  			});
  		},
  		false
  	);

  	function tabValidation(e) {
  		const invalidTabsName = getInvalidTabsName(e);

  		showInvalidFields(e);
  		showTabError(invalidTabsName);
  	}

  	function showInvalidFields(e) {
  		const form = e.srcElement;
  		const allBody = form.querySelectorAll('[iu-body]');

  		allBody.forEach(body => {
  			body.classList.remove('invalid');

  			if (body.querySelector('.form-control:invalid')) body.classList.add('invalid');
  		});
  	}

  	function showTabError(invalidTabsName) {
  		const tabs = document.querySelectorAll('.nav.nav-tabs [role="tab"]');

  		tabs.forEach(tab => {
  			if (invalidTabsName.includes(tab.id)) {
  				tab.classList.add('invalid');
  			} else {
  				tab.classList.remove('invalid');
  			}
  		});
  	}

  	function getInvalidTabsName(e) {
  		const form = e.srcElement;
  		const invalidElements = form.querySelectorAll('.was-validated .form-control:invalid');
  		const invalidTabsName = [];

  		invalidElements.forEach(element => {
  			const tabName = element.closest('[role="tabpanel"]').getAttribute('id');
  			invalidTabsName.push(tabName + '-tab');
  		});

  		return invalidTabsName
  	}

  	return false
  })();

  /**
   * Input fields formatter
   * @requires https://github.com/nosir/cleave.js
  */

  const inputFormatter = (() => {

    let input = document.querySelectorAll('[data-format]');
    if(input.length === 0) return;
    
    for(let i = 0; i < input.length; i++) {

      let targetInput = input[i],
          cardIcon = targetInput.parentNode.querySelector('.credit-card-icon'),
          options,
          formatter;
      if(targetInput.dataset.format != undefined) options = JSON.parse(targetInput.dataset.format);
      
      if (cardIcon) {
        formatter = new Cleave(targetInput, {...options, onCreditCardTypeChanged: (type) => {
          cardIcon.className = 'credit-card-icon ' + type;
        }});
      } else {
        formatter = new Cleave(targetInput, options);
      }
    }

  })();

  /**
   * Tooltip
   * @requires https://getbootstrap.com
   * @requires https://popper.js.org/
  */

  const tooltip = (() => {

    let tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));

    let tooltipList = tooltipTriggerList.map((tooltipTriggerEl) => new bootstrap.Tooltip(tooltipTriggerEl, { trigger: 'hover' }));

  })();

  /**
   * Popover
   * @requires https://getbootstrap.com
   * @requires https://popper.js.org/
   */

  const popover = (() => {

      let popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));

      let popoverList = popoverTriggerList.map((popoverTriggerEl) => new bootstrap.Popover(popoverTriggerEl));


      //let myDefaultAllowList = bootstrap.Tooltip.Default.allowList

      // To allow table elements
      //myDefaultAllowList['*'].push('onclick')

      // custom popover image-uploader
      let customPopoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="virtonex-popover"]'));

      let customPopoverList = customPopoverTriggerList.map((popoverTriggerEl) => new bootstrap.Popover(popoverTriggerEl, {
              customClass: 'virtonex-popover',
          })
      );

  })();

  /**
   * Toast
   * @requires https://getbootstrap.com
  */

  const toast = (() => {

    let toastElList = [].slice.call(document.querySelectorAll('.toast'));

    let toastList = toastElList.map((toastEl) => new bootstrap.Toast(toastEl));

  })();

  /**
   * Open YouTube video in lightbox
   * @requires https://github.com/sachinchoolur/lightGallery
  */

  const videoButton = (() => {

    let button = document.querySelectorAll('[data-bs-toggle="video"]');
    if (button.length) {
      for (let i = 0; i < button.length; i++) {
        lightGallery(button[i], {
          selector: 'this',
          plugins: [lgVideo],
          licenseKey: 'D4194FDD-48924833-A54AECA3-D6F8E646',
          download: false,
          youtubePlayerParams: {
            modestbranding: 1,
            showinfo: 0,
            rel: 0
          },
          vimeoPlayerParams: {
            byline: 0,
            portrait: 0,
            color: '6366f1'
          }
        });
      }
    }

  })();

  /**
   * Price switch
  */

  const priceSwitch = (() => {

    let switcherWrapper = document.querySelectorAll('.price-switch-wrapper');
    
    if (switcherWrapper.length <= 0) return;
    
    for (let i = 0; i < switcherWrapper.length; i++) {
      let switcher = switcherWrapper[i].querySelector('[data-bs-toggle="price"]');

      switcher.addEventListener('change', (e) => {
        let checkbox = e.currentTarget.querySelector('input[type="checkbox"]'),
            monthlyPrice = e.currentTarget.closest('.price-switch-wrapper').querySelectorAll('[data-monthly-price]'),
            annualPrice = e.currentTarget.closest('.price-switch-wrapper').querySelectorAll('[data-annual-price]');

        for (let n = 0; n < monthlyPrice.length; n++) {
          if (checkbox.checked == true) {
            monthlyPrice[n].classList.add('d-none');
          } else {
            monthlyPrice[n].classList.remove('d-none');
          }
        }

        for (let m = 0; m < monthlyPrice.length; m++) {
          if (checkbox.checked == true) {
            annualPrice[m].classList.remove('d-none');
          } else {
            annualPrice[m].classList.add('d-none');
          }
        }
      });
    }
    
  })();

  /**
   * Cascading (Masonry) grid layout
   * 
   * @requires https://github.com/desandro/imagesloaded
   * @requires https://github.com/Vestride/Shuffle
  */

  const masonryGrid = (() => {

    let grid = document.querySelectorAll('.masonry-grid'),
    masonry;

    if (grid === null) return;

      for (let i = 0; i < grid.length; i++) {
      masonry = new Shuffle(grid[i], {
        itemSelector: '.masonry-grid-item',
        sizer: '.masonry-grid-item'
      });

      imagesLoaded(grid[i]).on('progress', () => {
        masonry.layout();
      });

      // Filtering
      let filtersWrap = grid[i].closest('.masonry-filterable');
      if (filtersWrap === null) return;
      let filters = filtersWrap.querySelectorAll('.masonry-filters [data-group]');

      for (let n = 0; n < filters.length; n++) {
        filters[n].addEventListener('click', function(e) {
          let current = filtersWrap.querySelector('.masonry-filters .active'),
              target = this.dataset.group;
          if(current !== null) {
            current.classList.remove('active');
          }
          this.classList.add('active');
          masonry.filter(target);
          e.preventDefault();
        });
      }
    }

  })();

  /**
   * Ajaxify MailChimp subscription form
  */

  const subscriptionForm = (() => {

    const form = document.querySelectorAll('.subscription-form');

    if (form === null) return;

    for (let i = 0; i < form.length; i++) {

      let button = form[i].querySelector('button[type="submit"]'),
          buttonText = button.innerHTML,
          input = form[i].querySelector('.form-control'),
          antispam = form[i].querySelector('.subscription-form-antispam'),
          status = form[i].querySelector('.subscription-status');
      
      form[i].addEventListener('submit', function(e) {
        if (e) e.preventDefault();
        if (antispam.value !== '') return;
        register(this, button, input, buttonText, status);
      });
    }

    let register = (form, button, input, buttonText, status) => {
      button.innerHTML = 'Sending...';

      // Get url for MailChimp
      let url = form.action.replace('/post?', '/post-json?');

      // Add form data to object
      let data = '&' + input.name + '=' + encodeURIComponent(input.value);

      // Create and add post script to the DOM
      let script = document.createElement('script');
      script.src = url + '&c=callback' + data;
      document.body.appendChild(script);
      
      // Callback function
      let callback = 'callback';
      window[callback] = (response) => {

        // Remove post script from the DOM
        delete window[callback];
        document.body.removeChild(script);

        // Change button text back to initial
        button.innerHTML = buttonText;

        // Display content and apply styling to response message conditionally
        if(response.result == 'success') {
          input.classList.remove('is-invalid');
          input.classList.add('is-valid');
          status.classList.remove('status-error');
          status.classList.add('status-success');
          status.innerHTML = response.msg;
          setTimeout(() => {
            input.classList.remove('is-valid');
            status.innerHTML = '';
            status.classList.remove('status-success');
          }, 6000);
        } else {
          input.classList.remove('is-valid');
          input.classList.add('is-invalid');
          status.classList.remove('status-success');
          status.classList.add('status-error');
          status.innerHTML = response.msg.substring(4);
          setTimeout(() => {
            input.classList.remove('is-invalid');
            status.innerHTML = '';
            status.classList.remove('status-error');
          }, 6000);
        }
      };
    };
  })();

  /**
   * Play Lottie animations on hover
   * @requires https://github.com/LottieFiles/lottie-player
  */

  const hoverAnimation = (() => {

    const playerContainers = document.querySelectorAll('.animation-on-hover');
    playerContainers.forEach(container => {
      container.addEventListener('mouseover', () => {
        const players = container.querySelectorAll('lottie-player');
        players.forEach(player => {
          player.setDirection(1);
          player.play();
        });
      });
    
      container.addEventListener('mouseleave', () => {
        const players = container.querySelectorAll('lottie-player');
        players.forEach(player => {
          player.setDirection(-1);
          player.play();
        });
      });
    });

  })();

  /**
   * Mouse move parallax effect
   * @requires https://github.com/wagerfield/parallax
  */

  const audioPlayer = (() => {

    let player = document.querySelectorAll('.audio-player');

    if (player.length === 0) return;

    for (let i = 0; i < player.length; i++) {
      const playerContainer = player[i],
            audio = playerContainer.querySelector('audio'),
            playButton = playerContainer.querySelector('.ap-play-button'),
            seekSlider = playerContainer.querySelector('.ap-seek-slider'),
            volumeSlider = playerContainer.querySelector('.ap-volume-slider'),
            durationTimeLabel = playerContainer.querySelector('.ap-duration'),
            currentTimeLabel = playerContainer.querySelector('.ap-current-time');

      let playState = 'play',
          raf = null;

      // Start / stop audio
      playButton.addEventListener('click', (e) => {
        if(playState === 'play') {
          e.currentTarget.classList.add('ap-pause');
          audio.play();
          requestAnimationFrame(whilePlaying);
          playState = 'pause';
        } else {
          e.currentTarget.classList.remove('ap-pause');
          audio.pause();
          cancelAnimationFrame(raf);
          playState = 'play';
        }
      });

      // Instantiate sliders: Seek slider + Volume slider
      const showRangeProgress = (rangeInput) => {
        if(rangeInput === seekSlider) playerContainer.style.setProperty('--seek-before-width', rangeInput.value / rangeInput.max * 100 + '%');
        else playerContainer.style.setProperty('--volume-before-width', rangeInput.value / rangeInput.max * 100 + '%');
      };

      seekSlider.addEventListener('input', (e) => {
        showRangeProgress(e.target);
      });
      volumeSlider.addEventListener('input', (e) => {
        showRangeProgress(e.target);
      });

      const calculateTime = (secs) => {
        const minutes = Math.floor(secs / 60);
        const seconds = Math.floor(secs % 60);
        const returnedSeconds = seconds < 10 ? `0${seconds}` : `${seconds}`;
        return `${minutes}:${returnedSeconds}`;
      };

      const displayDuration = () => {
        durationTimeLabel.textContent = calculateTime(audio.duration);
      };

      const setSliderMax = () => {
        seekSlider.max = Math.floor(audio.duration);
      };

      const displayBufferedAmount = () => {
        const bufferedAmount = Math.floor(audio.buffered.end(audio.buffered.length - 1));
        playerContainer.style.setProperty('--buffered-width', `${(bufferedAmount / seekSlider.max) * 100}%`);
      };

      const whilePlaying = () => {
        seekSlider.value = Math.floor(audio.currentTime);
        currentTimeLabel.textContent = calculateTime(seekSlider.value);
        playerContainer.style.setProperty('--seek-before-width', `${seekSlider.value / seekSlider.max * 100}%`);
        raf = requestAnimationFrame(whilePlaying);
      };

      if (audio.readyState > 0) {
        displayDuration();
        setSliderMax();
        displayBufferedAmount();
      } else {
        audio.addEventListener('loadedmetadata', () => {
          displayDuration();
          setSliderMax();
          displayBufferedAmount();
        });
      }

      audio.addEventListener('progress', displayBufferedAmount);

      seekSlider.addEventListener('input', () => {
        currentTimeLabel.textContent = calculateTime(seekSlider.value);
        if(!audio.paused) {
            cancelAnimationFrame(raf);
        }
      });

      seekSlider.addEventListener('change', () => {
        audio.currentTime = seekSlider.value;
        if(!audio.paused) {
            requestAnimationFrame(whilePlaying);
        }
      });

      volumeSlider.addEventListener('input', (e) => {
        const value = e.target.value;
        audio.volume = value / 100;
      });
    }

  })();

  const scrollTab = (() => {

      if (document.querySelector('.virtonex-scroll-block') && document.querySelector('a[data-bs-toggle="tab"]')) {
          let tabElements = document.querySelectorAll('a[data-bs-toggle="tab"]');

          tabElements.forEach(element => {
              element.addEventListener('shown.bs.tab', function (event) {
                  document.querySelector('.virtonex-scroll-block').scrollTop = 0;
              });
          });

      }

  })();

  const virtonexSteps = (() => {
  (function step1_location() {
  		const step1TabList = getTabList('#step1TabList');

  		if (step1TabList) {
  			const tabLists = getTabLists(step1TabList, '.nav-link');

  			setTabListsEvent(tabLists, changeLocationInputValue);
  		}

  		function getTabList(selector) {
  			return document.querySelector(selector)
  		}
  		function getTabLists(tabList, selector) {
  			return tabList.querySelectorAll(selector)
  		}

  		function setTabListsEvent(mainElement, callback) {
  			mainElement.forEach(item => item.addEventListener('click', callback));
  		}

  		function changeLocationInputValue(event) {
  			const locationInput = document.querySelector('#step1_location');
  			const tabList = event.target;
  			const value = tabList.getAttribute('aria-controls');

  			if (locationInput && value) locationInput.value = value;
  		}
  	})()
  	;(function step5_spaceStatus() {
  		const spanSpaceStatus = document.querySelector('#step5_spaceStatus');
  		const radioButton1 = document.querySelector('#step5_spaceStatusPrivate');
  		const radioButton2 = document.querySelector('#step5_spaceStatusPublic');

  		if (spanSpaceStatus && radioButton1 && radioButton2) {
  			radioButton1.addEventListener('change', () => {
  				setSpaceStatus('приватное');
  				setSpaceStatusColor('text-marine');
  			});

  			radioButton2.addEventListener('change', () => {
  				setSpaceStatus('публичное');
  				setSpaceStatusColor('text-success');
  			});
  		}

  		function setSpaceStatus(status) {
  			spanSpaceStatus.textContent = status;
  		}

  		function setSpaceStatusColor(clasList) {
  			spanSpaceStatus.classList = clasList;
  		}
  	})()
  	;(function step5SpaceType() {
  		const spaceType = document.querySelector('#step5_spacingType');

  		if (spaceType) {
  			spaceType.addEventListener('change', e => {
  				const type = e.target.value;
  				const temporaryBlock = document.querySelector('#temporary');
  				const selectTimeStart = document.querySelector('#step5_timeStart');
  				const selectTimeEnd = document.querySelector('#step5_timeEnd');

  				if (type == 'permanent') {
  					temporaryBlock.style.display = 'none';
  					selectTimeStart.removeAttribute('disabled');
  					selectTimeEnd.removeAttribute('disabled');
  				}

  				if (type == 'temporary') {
  					temporaryBlock.style.display = 'block';
  					selectTimeStart.setAttribute('disabled', '');
  					selectTimeEnd.setAttribute('disabled', '');
  				}
  			});
  		}
  	})();

  	return true
  })();

  const inputPasswordCustom = (() => {

      const inputsPassword = getInputsPassword();

      inputsPassword.forEach(inputPassword => {
          const inputBody = getInputBody(inputPassword);
          const buttonToggle = getButtonToggle(inputBody);

          buttonToggle.addEventListener('click',() => {

              if (inputPassword.type == 'password') {
                  inputPassword.type = 'text';
              } else {
                  inputPassword.type = 'password';
              }
          });
      });

      function getInputsPassword() {
          return document.querySelectorAll('#virtonex [type="password"]')
      }

      function getInputBody(input) {
          return input.closest('div.input-group.form-floating')
      }

      function getButtonToggle(inputBody) {
          return inputBody.querySelector('span .password-toggle-indicator')
      }

  })();

  const backLink = (() => {
      const backLink = document.querySelector('#backLink');

      if (backLink) {
          backLink.addEventListener('click', event => {
              history.back();
          });
      }
  })();

  const virtonexUploader = (() => {
  	class Uploader {
  		initBasicUploaders() {
  			this.setInputsAction('[iu-target-action="edit"]', e => this.actionEdit(e));
  			this.setInputsAction('[iu-target-action="multiple"]', e => this.actionMultiple(e));
  		}
  		initRequired() {
  			const requiredBody = document.querySelectorAll('[iu-body][required]');

  			requiredBody.forEach(body => this.createRequired(body));
  		}
  		getItems(body) {
  			return body.querySelectorAll('[iu-item]')
  		}
  		getAcceptFormat(body) {
  			return body.hasAttribute('accept') ? body.getAttribute('accept') : 'image/jpeg,image/png'
  		}
  		getInputName(body) {
  			return body.getAttribute('iu-input-name')
  		}
  		getItemName(item) {
  			return item.querySelector('[iu-file-name]').textContent
  		}
  		getItemImage(item) {
  			return item.querySelector('[iu-image]')
  		}
  		getBody(e) {
  			return e.target.closest('[iu-body]')
  		}
  		getItem(e) {
  			return e.target.closest('[iu-item]')
  		}
  		getElementInItem(e, selector) {
  			const item = this.getItem(e);

  			return item.querySelector(selector)
  		}
  		getBodyNumber(e) {
  			const target = e.target;
  			let bodyNumber = target.getAttribute('iu-target-body');

  			if (bodyNumber === null) {
  				bodyNumber = target.closest('[iu-target-body]').getAttribute('iu-target-body');
  			}

  			return bodyNumber
  		}
  		setItemInputName(item, name, selector) {
  			const inputFile = item.querySelector(selector);

  			if (inputFile) inputFile.setAttribute('name', name);
  		}
  		setItemActions(item) {
  			const inputEditModal = item.querySelector('[iu-target-action="openEditModal"]');
  			const inputDeleteModal = item.querySelector('[iu-target-action="openDeleteModal"]');

  			inputEditModal.addEventListener('click', event => mainEditModal.show(event));
  			inputDeleteModal.addEventListener('click', event => mainDeleteModal.show(event));
  		}
  		setFileInInput(item) {
  			const input = item.querySelector('[iu-input]');

  			// change set file logic
  			input.addEventListener('change', event => {
  				let target = event.target || event.srcElement;
  				let file = target.files[0];

  				const validFileSizeResponse = this.validFileSize(file);

  				if (!validFileSizeResponse.valid) {
  					const alert = new VirtonexAlert('alert-warning', validFileSizeResponse.message);
  					input.value = '';
  					alert.show();
  					return
  				}

  				if (target.hasAttribute('iu-preview')) this.setFileInPreview(file);

  				this.setIcon(item, file);
  				if (this.getItemName(item) === '') this.setName(item, file.name);
  				this.setPopover(item);

  				item.classList = 'd-flex';
  			});

  			input.dispatchEvent(new MouseEvent('click', { bubbles: true }));
  		}
  		setPopover(item) {
  			const popoverAction = item.querySelector('[iu-popover-action]');

  			if (popoverAction) {
  				popoverAction.addEventListener('focus', e => {
  					e.target.querySelector('[iu-popover]').style.display = 'flex';
  				});

  				popoverAction.addEventListener('blur', e => {
  					e.target.querySelector('[iu-popover]').style.display = 'none';
  				});
  			}
  		}
  		setName(item, name) {
  			const iuName = item.querySelector('[iu-file-name]');

  			iuName.textContent = name;
  		}
  		setImageSvgIcon(item, classname) {
  			const icon = item.querySelector('[iu-image]');

  			const newIconElement = document.createElement('i');
  			newIconElement.setAttribute('iu-image', '');
  			newIconElement.classList = classname;
  			icon.closest('div').prepend(newIconElement);

  			icon.remove();
  		}
  		async setIcon(item, file) {
  			const icon = item.querySelector('[iu-image]');
  			const type = file.type;

  			console.log(type);

  			if (icon && type) {
  				if (type === 'image/jpeg' || type === 'image/png') {
  					const base64 = await this.convertBase64(file);
  					icon.src = base64;
  				}

  				if (type === 'video/mp4') {
  					icon.classList = 'icon';
  					icon.src =
  						'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAOhJREFUSEvtluENgjAUhO9tIpu4iTqJOolsYpxENjlzDW0KUVLT0vKD/iTwvt7r9R6GRssacbGDq3V+O60m+QBwyJD+AtCb2bBUY6KYJDOA80+7JXgAk7wBuBYEX8ys/1VvTfDdzCTGLZJnHaF/VgU8+kbgsJnVwSSfAI6j8Cpgna9uh4eKXQX8zVc72Nm99D1u1mqZS8aK47fKGTtIi+sU1DUJkCgy5aHB53ecXIo0jcRSa5LVY14rq924nI/Fd+Ys9puWsu6feSwXnjLhUiS16T8CpXqcUmc7/1wpuy3xzq64RBeTanwA9ZV/HyOBgXkAAAAASUVORK5CYII=\n';
  					//setImageSvgIcon(item, 'bx bx-video')
  					return
  				}

  				if (type === 'audio/mp3' || type === 'audio/mpeg') {
  					icon.classList = 'icon';
  					icon.src =
  						'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAAAXFJREFUSEvtlt1xAjEQg7WdQCVJKkmoBKgkUAmkktCJGDHeGZ/jv7tzwkv8COP7tGtpbcOTlj2Ji24wyQ2AVwBXM7utFTwH/A1AcC2Bj2Z2WipgDpgZiARcAXzNFbEE7G326l2PizibmcRU1xKwWnwgqfN+B/BR6MQZwKnkh8Vgh0WmkwiJSVfWD6vBMaUh4i0+gqHgjAgdwz78/jdgwYIPLv9gdSB7xqFFcuiLhkMYEt6yR5xaOZ3dapIC5GLhrPFgkp+FgRAX+Cvg3DxOuzoWTFKZU8WtNRwsw3jYa/Bd6SYi6aaTKTWrdZHUB0gS9hp4mw7+MCrVrZop85Orc/PNzLapqo4kaEt5ZAa4XhqlNdkcstrrjfqsLlSuq00bf7y1OiNYrzhzu6D1sOtssz498Ub3tVjqfXByMw1mNmGNACsyNV9Is55Au1j8anCHwbJJGAKObiK13LP8eHWmlXrVw8D+wZCKTeuJOxzcGvT+/x1qUOwfP4v6bgAAAABJRU5ErkJggg==\n';
  					//setImageSvgIcon(item, 'bx bx-music')
  					return
  				}
  			}
  		}
  		setInputsAction(selector, action) {
  			const inputs = document.querySelectorAll(selector);

  			inputs.forEach(input => input.addEventListener('click', e => action(e)));
  		}
  		setItemsInputName(body) {
  			const items = this.getItems(body);
  			const inputName = this.getInputName(body);

  			items.forEach((item, index) => {
  				this.setItemInputName(item, inputName + (index + 1), '[iu-input]');
  				this.setItemInputName(item, inputName + (index + 1) + '_description', '[iu-description]');
  			});
  		}
  		setFileInPreview(file, selector) {
  			const reader = new FileReader();

  			reader.onload = function (e) {
  				document
  					.querySelector('[iu-input-name="step2_event-preview"]')
  					.setAttribute('style', `background-image:url("${e.target.result}")`);
  			};

  			reader.readAsDataURL(file);
  		}
  		actionEdit(e) {
  			const bodyNumber = this.getBodyNumber(e);

  			const body = document.querySelector(`[iu-body='${bodyNumber}']`);
  			body.innerHTML = '';

  			this.addImageItem(bodyNumber);
  		}
  		actionDelete(e) {
  			const item = this.getItem(e);
  			const body = this.getBody(e);

  			item.remove();

  			this.createRequired(body);
  			this.setItemsInputName(body);
  		}
  		actionPopoverEdit(e) {
  			const bodyNumber = e.target.closest('[iu-body]').getAttribute('iu-body');

  			this.actionDelete(e);

  			this.addImageItem(bodyNumber);
  		}
  		addImageItem(bodyNumber) {
  			const body = document.querySelector(`[iu-body='${bodyNumber}']`);

  			this.removeRequired(body);
  			const item = this.createItem(body);

  			this.setFileInInput(item);

  			body.append(item);

  			this.setItemActions(item);
  			this.setItemsInputName(body);
  		}
  		actionMultiple(e) {
  			const bodyNumber = this.getBodyNumber(e);

  			this.addImageItem(bodyNumber);
  		}
  		createItem(body) {
  			const inputName = this.getInputName(body);
  			const acceptFormat = this.getAcceptFormat(body);
  			const required = this.hasBodyRequired(body) ? 'required' : '';

  			const item = document.createElement('div');
  			item.setAttribute('iu-item', '');
  			item.innerHTML = `<div class='d-flex align-items-center'> <img iu-image> <span iu-file-name></span> <input class='form-control' type="file" name="${inputName}" iu-input style="display: none;" accept='${acceptFormat}' ${required}> </div><div class="icon-points" iu-popover-action tabindex="0"> <div iu-popover> <span iu-target-action='openEditModal'><i class="icon-edit size-sm"></i>Редактировать</span> <span iu-target-action='openDeleteModal'"><i class="icon-delete size-sm"></i>Удалить</span> </div></div>`;

  			return item
  		}
  		createRequired(body) {
  			if (!body.querySelector('[iu-required]')) {
  				const item = this.createItem(body);

  				item.setAttribute('iu-required', '');
  				item.style.display = 'none';

  				body.append(item);
  			}
  		}
  		hasBodyRequired(body) {
  			return body.hasAttribute('required')
  		}
  		removeRequired(body) {
  			const required = body.querySelector('[iu-required]');

  			if (required) {
  				required.remove();
  			}
  			body.classList.remove('invalid');
  		}
  		validFileSize(file) {
  			const type = file.type;
  			const fileSize = file.size;

  			const message1 = 'У загруженного файла не верный формат';
  			const message2 = 'Размер файла превышает допустимый';

  			if (type === 'image/jpeg' || type === 'image/png') return this.checkFileSize(fileSize, 10485760, message2)

  			if (type === 'video/mp4') return this.checkFileSize(fileSize, 31457280, message2)

  			if (type === 'audio/mp3' || type === 'audio/mpeg') return this.checkFileSize(fileSize, 20971520, message2)

  			return { valid: false, message: message1 }
  		}
  		checkFileSize(fileSize, sizeLimit, message2) {
  			if (fileSize < sizeLimit) {
  				return { valid: true }
  			} else {
  				return { valid: false, message: message2 }
  			}
  		}
  		convertBase64(file) {
  			return new Promise((resolve, reject) => {
  				const fileReader = new FileReader();
  				fileReader.readAsDataURL(file);

  				fileReader.onload = () => {
  					resolve(fileReader.result);
  				};

  				fileReader.onerror = error => {
  					reject(error);
  				};
  			})
  		}
  	}

  	class VirtonexAlert {
  		constructor(additionalClass, message) {
  			this.additionalClass = additionalClass;
  			this.message = message;
  			this.alertsBlock = this.getAlertsBlock();

  			this.alert = this.create();
  		}
  		getAlertsBlock() {
  			let alertsBlock = document.querySelector('.alerts');

  			if (!alertsBlock) {
  				alertsBlock = this.initAlertsBlock(alertsBlock);
  			}

  			return alertsBlock
  		}
  		initAlertsBlock(alertsBlock) {
  			alertsBlock = document.createElement('div');
  			alertsBlock.classList = 'alerts';

  			document.body.append(alertsBlock);

  			return alertsBlock
  		}
  		create() {
  			const alert = document.createElement('div');
  			alert.classList = `alert ${this.additionalClass}`;

  			const closeButton = this.getCloseButton();

  			alert.innerHTML = `<div>${this.message}</div>${closeButton}`;

  			return alert
  		}
  		show() {
  			this.alertsBlock.append(this.alert);

  			new bootstrap.Alert(this.alert);
  		}
  		getCloseButton() {
  			return '<button type="button" class="icon-close-cross text-black icon-size-md" className="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>'
  		}
  	}

  	class UploaderPreview extends Uploader {
  		constructor(bodyNumber, imageSrc) {
  			super();
  			this.setInputsAction('[iu-target-action="editEventPreview"]', e => this.actionEditEventPreview(e));
  			this.loadDefaultImage(bodyNumber, imageSrc);
  		}
  		loadDefaultImage(bodyNumber, imageSrc) {
  			const body = document.querySelector(`[iu-body="${bodyNumber}"]`);
  			const item = this.createEventPreviewItem(body);
  			this.handleResumeInput(imageSrc, item);

  			body.append(item);
  		}
  		actionEditEventPreview(e) {
  			const bodyNumber = this.getBodyNumber(e);

  			const body = document.querySelector(`[iu-body='${bodyNumber}']`);

  			const item = this.createEventPreviewItem(body);

  			this.setFileInInput(item);

  			body.append(item);
  		}
  		createEventPreviewItem(body) {
  			this.removeAllItems(body);

  			const acceptFormat = this.getAcceptFormat(body);

  			const inputName = this.getInputName(body);
  			const item = document.createElement('div');
  			item.setAttribute('iu-item', '');
  			item.innerHTML = `<input class='form-control' type="file" name="${inputName}" iu-input style="display: none;" accept='${acceptFormat}' iu-preview>`;

  			return item
  		}
  		async handleResumeInput(remoteResumeURL, item) {
  			const designFile = await this.createFile(remoteResumeURL);
  			const input = item.querySelector('[iu-input]');
  			const dt = new DataTransfer();
  			dt.items.add(designFile);
  			input.files = dt.files;
  			const event = new Event('change', {
  				bubbles: !0,
  			});
  			input.dispatchEvent(event);
  		}
  		async createFile(url) {
  			let response = await fetch(url);
  			let data = await response.blob();
  			let metadata = {
  				type: 'image/webp',
  			};
  			return new File([data], '4.webp', metadata)
  		}
  		removeAllItems(body) {
  			const items = this.getItems(body);

  			items.forEach(item => item.remove());
  		}
  	}

  	class VirtonexModal {
  		constructor(uploader) {
  			this.uploader = new Uploader();
  		}
  		getModalElement(m, selector) {
  			return m._element.querySelector(selector)
  		}
  		setDescriptionValue(e, m) {
  			const itemDescription = this.uploader.getElementInItem(e, '[iu-description]');
  			let description = this.getModalElement(m, '[iu-modal-edit-textarea-description]');

  			description.value = itemDescription ? itemDescription.value : '';
  		}
  		setItemDescriptionValue(e, m, selector) {
  			let itemDescription = this.uploader.getElementInItem(e, '[iu-description]');
  			const description = this.getModalElement(m, selector);
  			const value = description.value;

  			if (value !== '') {
  				!itemDescription ? this.createDescription(e, value) : (itemDescription.value = value);
  				this.uploader.setItemsInputName(this.uploader.getBody(e));
  			}
  		}
  		setIconDeleteAction(e, m) {
  			this.clearAllElementActions(m, '[iu-modal-edit-icon-delete-action]');

  			const iconDeleteButton = this.getModalElement(m, '[iu-modal-edit-icon-delete-action]');

  			iconDeleteButton.addEventListener('click', () => {
  				m.hide();
  				mainDeleteModal.show(e);
  			});
  		}
  		setItemInputNameFile(newFileName, item) {
  			const itemInputNameFile = item.querySelector('[iu-input]');

  			let file4 = itemInputNameFile.files[0];

  			let blob = file4.slice(0, file4.size, 'image/png');

  			let file = new File([blob], newFileName, { type: 'image/jpeg', lastModified: new Date().getTime() });

  			let container = new DataTransfer();
  			container.items.add(file);

  			itemInputNameFile.files = container.files;

  			if (itemInputNameFile.webkitEntries.length) {
  				itemInputNameFile.dataset.file = `${container.files[0].name}`;
  			}
  		}
  		setInputName(e, m) {
  			const inputEditName = this.getModalElement(m, '[iu-modal-edit-input-name]');

  			const item = this.uploader.getItem(e);
  			inputEditName.value = this.uploader.getItemName(item);
  		}
  		setFileName(event, modal) {
  			const spanName = this.getModalElement(modal, '[iu-modal-view-span-name]');

  			const item = this.uploader.getItem(event);
  			spanName.textContent = this.uploader.getItemName(item);
  		}
  		setImage(e, m) {
  			const elementImage = this.getModalElement(m, '[iu-modal-image]');

  			const item = this.uploader.getItem(e);
  			elementImage.src = this.uploader.getItemImage(item).src;
  		}
  		setButtonAction(e, m, selector, action) {
  			this.clearAllElementActions(m, selector);

  			const button = this.getModalElement(m, selector);

  			const buttonAction = () => {
  				action(m, e);
  			};

  			button.addEventListener('click', buttonAction);
  		}
  		createDescription(e, value) {
  			const itemDescription = document.createElement('input');
  			itemDescription.type = 'hidden';
  			itemDescription.setAttribute('iu-description', '');
  			itemDescription.value = value;

  			const item = this.uploader.getItem(e);
  			const inputParent = item.querySelector('[iu-file-name]').closest('div');
  			inputParent.append(itemDescription);
  		}
  		buttonSaveChangesAction(m, e) {
  			const inputEditName = this.getModalElement(m, '[iu-modal-edit-input-name]');
  			const changedFileName = inputEditName.value;
  			const item = this.uploader.getItem(e);

  			this.uploader.setName(item, changedFileName);
  			this.setItemInputNameFile(changedFileName, item);
  			this.setItemDescriptionValue(e, m, '[iu-modal-edit-textarea-description]');
  		}
  		clearAllElementActions(m, selector) {
  			const element = this.getModalElement(m, selector);

  			element.replaceWith(element.cloneNode(true));
  		}
  		checkUploadedFile(inputFile) {
  			if (!document.querySelector('#imagePreview')) {
  				const imagePreview = document.createElement('img');
  				imagePreview.id = 'imagePreview';
  				document.body.prepend(imagePreview);
  			}

  			var reader = new FileReader();

  			reader.onload = function (e) {
  				document.querySelector('#imagePreview').setAttribute('src', e.target.result);
  			};

  			reader.readAsDataURL(inputFile.files[0]);
  		}
  	}

  	class EditModal extends VirtonexModal {
  		constructor(selector) {
  			super();
  			this.m = new bootstrap.Modal(document.querySelector(selector));
  		}
  		show(e) {
  			this.setFileName(e, this.m);
  			this.setImage(e, this.m);
  			this.setInputName(e, this.m);
  			this.setIconDeleteAction(e, this.m);
  			this.setDescriptionValue(e, this.m);
  			this.setButtonAction(e, this.m, '[iu-modal-button-save-changes]', this.buttonSaveChangesAction.bind(this));

  			this.m.show();
  		}
  	}

  	class DeleteModal extends VirtonexModal {
  		constructor(selector) {
  			super();
  			this.m = new bootstrap.Modal(document.querySelector(selector));
  		}
  		show(e) {
  			this.setFileName(e, this.m);
  			this.setImage(e, this.m);
  			this.setButtonAction(e, this.m, '[iu-modal-button-delete]', (modal, event) => {
  				this.uploader.actionDelete(event);
  			});

  			this.m.show();
  		}
  	}

  	class PartnersUploader extends Uploader {
  		constructor() {
  			super();
  			this.setInputsAction('[iu-target-action="partners"]', e => this.actionPartners(e));
  		}
  		actionPartners(e) {
  			const bodyNumber = this.getBodyNumber(e);

  			this.addImageItem(bodyNumber);
  		}
  		addImageItem(bodyNumber) {
  			const body = document.querySelector(`[iu-body='${bodyNumber}']`);

  			const item = this.createItem(body);

  			body.append(item);

  			this.setPopover(item);
  			this.setItemActions(item);
  			this.setItemsInputName(body);
  		}
  		setItemsInputName(body) {
  			const items = this.getItems(body);
  			const inputName = this.getInputName(body);

  			items.forEach((item, index) => {
  				this.setItemInputName(item, inputName + (index + 1) + '_image', '[iu-input-image]');
  				this.setItemInputName(item, inputName + (index + 1) + '_name', '[iu-input-name]');
  				this.setItemInputName(item, inputName + (index + 1) + '_link', '[iu-input-link]');
  			});
  		}
  		createItem(body) {
  			const inputName = this.getInputName(body);
  			const acceptFormat = this.getAcceptFormat(body);
  			const mainBlock = `<div class='d-flex align-items-center'>
<img iu-image>
<span iu-name></span>
<input class='form-control' type="file" name="${inputName}_image" iu-input-image style="display: none;" accept='${acceptFormat}'>
<input class='form-control' type="hidden" name="${inputName}_name" iu-input-name>
<input class='form-control' type="hidden" name="${inputName}_link" iu-input-link>
</div>`;
  			const popoverBlock = `<div class="icon-points" iu-popover-action tabindex="0"> <div iu-popover> <span iu-target-action='editPartnerModal'><i class="icon-edit size-sm"></i>Редактировать</span> <span iu-target-action='deletePartnerModal'"><i class="icon-delete size-sm"></i>Удалить</span> </div></div>`;

  			const item = document.createElement('div');
  			item.classList = 'd-flex';
  			item.setAttribute('iu-item', '');
  			item.innerHTML = mainBlock + popoverBlock;

  			return item
  		}
  		setItemActions(item) {
  			const inputEditPartnerModal = item.querySelector('[iu-target-action="editPartnerModal"]');
  			const inputDeletePartnerModal = item.querySelector('[iu-target-action="deletePartnerModal"]');

  			inputEditPartnerModal.addEventListener('click', event => mainPartnersModal.show(event));
  			inputDeletePartnerModal.addEventListener('click', item => this.actionDelete(item));

  			inputEditPartnerModal.click();
  		}
  		getPartnerInputName(item) {
  			return item.querySelector('[iu-input-name]').value
  		}
  		getPartnerInputLink(item) {
  			return item.querySelector('[iu-input-link]').value
  		}
  		getPartnerInputImageName(item) {
  			const partnerInputImage = item.querySelector('[iu-input-image]');
  			const file = partnerInputImage.files[0];

  			if (file) return file.name
  			return null
  		}
  		setPartnerInputName(item, name) {
  			const iuPartnerInputName = item.querySelector('[iu-input-name]');
  			const iuPartnerName = item.querySelector('[iu-name]');

  			iuPartnerInputName.value = name;
  			iuPartnerName.textContent = name;
  		}
  		setPartnerInputLink(item, name) {
  			const iuPartnerInputLink = item.querySelector('[iu-input-link]');

  			iuPartnerInputLink.value = name;
  		}
  		setPartnerImage(item, src) {
  			const iuPartnerImage = item.querySelector('[iu-image]');

  			if (src !== null) {
  				iuPartnerImage.src = src;
  			} else {
  				iuPartnerImage.removeAttribute('src');
  			}
  		}
  		setPartnerInputImage(item, value) {
  			const iuPartnerInputImage = item.querySelector('[iu-input-image]');

  			iuPartnerInputImage.value = value;
  		}
  		setFileInInput(e, m, item) {
  			this.clearAllElementActions(item, '[iu-input-image]');
  			const input = item.querySelector('[iu-input-image]');

  			input.addEventListener('change', event => {
  				let target = event.target || event.srcElement;
  				let file = target.files[0];

  				const validFileSizeResponse = this.validFileSize(file);

  				if (!validFileSizeResponse.valid) {
  					const alert = new VirtonexAlert('alert-warning', validFileSizeResponse.message);
  					input.value = '';
  					this.setPartnerImage(item, null);
  					mainPartnersModal.setImageBlock(e, m);
  					alert.show();
  					return
  				}
  (async () => {
  					await this.setIcon(item, file);
  					await mainPartnersModal.setImageBlock(e, m);
  				})();
  			});

  			input.dispatchEvent(new MouseEvent('click', { bubbles: true }));
  		}
  		clearAllElementActions(item, selector) {
  			const element = item.querySelector(selector);

  			element.replaceWith(element.cloneNode(true));
  		}
  		actionDelete(e) {
  			const item = this.getItem(e);

  			item.remove();
  		}
  	}

  	class PartnersModal extends VirtonexModal {
  		constructor(selector) {
  			super();
  			this.uploader = new PartnersUploader();
  			this.m = new bootstrap.Modal(document.querySelector(selector));
  		}
  		show(e) {
  			this.setPartnerName(e, this.m);
  			this.setPartnerLink(e, this.m);
  			this.setImageBlock(e, this.m);
  			this.setButtonAction(e, this.m, '[iu-modal-button-save-changes]', this.buttonSaveChangesAction.bind(this));
  			this.setButtonAction(e, this.m, '[iu-modal-button-add-logo]', this.loadLogotypeAction.bind(this));

  			this.m.show();
  		}
  		buttonSaveChangesAction(m, e) {
  			const item = this.uploader.getItem(e);
  			const inputPartnerName = this.getModalElement(m, '[iu-modal-partner-name]');
  			const inputPartnerLink = this.getModalElement(m, '[iu-modal-partner-link]');

  			if (inputPartnerName.value !== '') {
  				this.uploader.setPartnerInputName(item, inputPartnerName.value);
  				this.uploader.setPartnerInputLink(item, inputPartnerLink.value);

  				inputPartnerName.classList.remove('invalid');

  				m.hide();
  			} else {
  				inputPartnerName.classList.add('invalid');
  			}
  		}
  		setPartnerName(e, m) {
  			const inputPartnerName = this.getModalElement(m, '[iu-modal-partner-name]');

  			const item = this.uploader.getItem(e);
  			inputPartnerName.value = this.uploader.getPartnerInputName(item);
  		}
  		setPartnerLink(e, m) {
  			const inputPartnerName = this.getModalElement(m, '[iu-modal-partner-link]');

  			const item = this.uploader.getItem(e);
  			inputPartnerName.value = this.uploader.getPartnerInputLink(item);
  		}
  		setImageBlock(e, m) {
  			const body = this.getModalElement(m, '[iu-modal-body]');
  			const item = this.uploader.getItem(e);
  			const uploaderImageSrc = this.uploader.getItemImage(item).src;

  			if (uploaderImageSrc) {
  				this.setImage(e, m, uploaderImageSrc);
  				this.setFileName(e, m);
  				this.setIconDeleteAction(e, this.m);

  				this.setAddLogotypeButtonText(e, m, 'Изменить логотип');
  				body.classList.remove('d-none');
  			} else {
  				this.setAddLogotypeButtonText(e, m, 'Добавить логотип');
  				body.classList.add('d-none');
  			}

  			return true
  		}
  		loadLogotypeAction(m, e) {
  			const item = this.uploader.getItem(e);
  			this.uploader.setFileInInput(e, m, item);
  		}
  		setIconDeleteAction(e, m) {
  			this.clearAllElementActions(m, '[iu-modal-edit-icon-delete-action]');

  			const iconDeleteButton = this.getModalElement(m, '[iu-modal-edit-icon-delete-action]');

  			iconDeleteButton.addEventListener('click', () => {
  				const body = this.getModalElement(m, '[iu-modal-body]');
  				const item = this.uploader.getItem(e);

  				body.classList.add('d-none');
  				this.uploader.setPartnerImage(item, null);
  				this.uploader.setPartnerInputImage(item, null);
  				this.setAddLogotypeButtonText(e, m, 'Добавить логотип');
  			});
  		}
  		setImage(e, m, src) {
  			const elementImage = this.getModalElement(m, '[iu-modal-image]');

  			elementImage.src = src;
  		}
  		setFileName(e, m) {
  			const item = this.uploader.getItem(e);
  			const inputPartnerImageName = this.uploader.getPartnerInputImageName(item);
  			const spanName = this.getModalElement(m, '[iu-modal-view-span-name]');

  			spanName.textContent = inputPartnerImageName;
  		}
  		setAddLogotypeButtonText(e, m, text) {
  			const loadLogotypeButton = this.getModalElement(m, '[iu-modal-button-add-logo]');

  			loadLogotypeButton.querySelector('.actionText').textContent = text;
  		}
  	}

  	const uploader = new Uploader();
  	uploader.initBasicUploaders();
  	uploader.initRequired();

  	let mainEditModal = null;
  	let mainDeleteModal = null;
  	let mainPartnersModal = null;

  	if (document.querySelector('#modal-edit-file') && document.querySelector('#modal-delete-file')) {
  		mainEditModal = new EditModal('#modal-edit-file');
  		mainDeleteModal = new DeleteModal('#modal-delete-file');
  	}
  	if (document.querySelector('#modal-partners')) {
  		mainPartnersModal = new PartnersModal('#modal-partners');
  		new UploaderPreview(44, 'assets/img/virtonex/cards/4.webp');
  	}

  	return true
  })();

  const contacts = (() => {
  	class Storage {
  		constructor(array = []) {
  			this.data = array;
  		}
  		add(obj) {
  			this.data = [...this.data, obj];
  		}
  		remove(id) {
  			this.data = this.data.filter(obj => obj.id !== id);
  		}
  	}

  	class Modal {
  		constructor(selector) {
  			this.modal = new bootstrap.Modal(document.querySelector(selector));
  		}
  		show() {
  			this.modal.show();
  		}
  		showOnClick(selector) {
  			const button = document.querySelector(selector);

  			button.addEventListener('click', () => this.modal.show());
  		}
  		hide() {
  			this.modal.hide();
  		}
  		hideOnClick(selector) {
  			const button = document.querySelector(selector);

  			button.addEventListener('click', () => this.modal.hide());
  		}
  		createAction(selector, callback) {
  			const button = this.modal._element.querySelector(selector);

  			button.addEventListener('click', callback);
  		}
  		getElement(selector) {
  			return this.modal._element.querySelector(selector)
  		}
  	}

  	class UploaderItem {
  		constructor(id) {
  			this._element = null;
  			this.id = id;
  		}
  		set(html, classList) {
  			this._element = document.createElement('div');
  			this._element.setAttribute('iu-item', '');
  			this._element.classList = classList;

  			this._element.innerHTML = `<div class='d-flex align-items-center'>` + html + `</div>`;

  			return this._element
  		}
  		setPopover(editAction = null, removeAction = null, profileAction = null) {
  			const popover = document.createElement('div');
  			popover.classList = 'icon-points';
  			popover.setAttribute('iu-popover-action', '');
  			popover.setAttribute('tabindex', '0');

  			popover.addEventListener('focus', e => {
  				e.target.querySelector('[iu-popover]').style.display = 'flex';
  			});

  			popover.addEventListener('blur', e => {
  				e.target.querySelector('[iu-popover]').style.display = 'none';
  			});

  			if (editAction || removeAction || profileAction) {
  				const wrapperButton = document.createElement('div');
  				wrapperButton.setAttribute('iu-popover', '');

  				if (editAction) {
  					const editButton = document.createElement('span');
  					editButton.innerHTML = '<i class="icon-edit size-sm"></i>Редактировать';
  					editButton.addEventListener('click', editAction);

  					wrapperButton.append(editButton);
  				}

  				if (removeAction) {
  					const deleteButton = document.createElement('span');
  					deleteButton.innerHTML = '<i class="icon-delete size-sm"></i>Удалить';
  					deleteButton.addEventListener('click', removeAction);

  					wrapperButton.append(deleteButton);
  				}

  				if (profileAction) {
  					const profileButton = document.createElement('span');
  					profileButton.innerHTML = '<i class="icon-user size-sm"></i>Профиль';
  					profileButton.addEventListener('click', profileAction);

  					wrapperButton.append(profileButton);
  				}

  				popover.append(wrapperButton);

  				this._element.append(popover);
  			}
  		}
  		get() {
  			return this._element
  		}
  	}

  	class UploaderBody {
  		constructor(selector, storage) {
  			this.body = document.querySelector(selector);
  			this.storage = storage;
  		}
  		create() {
  			this.storage.data.forEach(contact => {
  				this.body.append(contact.get());
  			});
  		}
  		update() {
  			this.body.innerHTML = '';

  			this.create();
  		}
  	}

  	if (document.querySelector('#modal-contact') && document.querySelector('[users-body]')) step3UsersComponent();
  	if (document.querySelector('#profile_contact_user') && document.querySelector('[contacts-body]'))
  		profileContactsComponent();

  	function step3UsersComponent() {
  		const usersStorage = new Storage();
  		const contactModal = new Modal('#modal-contact');
  		const usersBody = new UploaderBody('[users-body]', usersStorage);

  		contactModal.showOnClick('[modal-open]');
  		contactModal.createAction('[modal-add-user]', () => {
  			const email = contactModal.getElement('#step3_createNewContact_email').value;
  			const role = contactModal.getElement('#step3_createNewUser_role').value;

  			const newUserId = usersStorage.data.length;

  			let newUser = new UploaderItem(newUserId);
  			newUser.set(
  				`<span>${email}</span>
				<input class='form-control' type="hidden" name="step3_contact${newUserId}_email" value='${email}'>
				<input class='form-control' type="hidden" name="step3_contact${newUserId}_role" value='${role}'>`,
  				'd-flex'
  			);
  			newUser.setPopover(null, e => {
  				usersStorage.remove(newUserId);
  				usersBody.update();
  			});
  			usersStorage.add(newUser);
  			usersBody.update();

  			contactModal.hide();
  		});
  	}

  	function profileContactsComponent() {
  		const contactsStorage = new Storage();
  		const contactModal = new Modal('#profile_contact_user');
  		const contactsBody = new UploaderBody('[contacts-body]', contactsStorage);

  		const initialContacts = [
  			{ name: 'Иван Петров', src: 'assets/img/virtonex/man.webp' },
  			{ name: 'Олег Кузнецов', src: 'assets/img/virtonex/man.webp' },
  			{ name: 'Александр Попов', src: 'assets/img/virtonex/man.webp' },
  		];

  		initialContacts.forEach(contact => {
  			const newUserId = contactsStorage.data.length;
  			let newUser = new UploaderItem(newUserId);
  			newUser.set(
  				`<img src='${contact.src}' class="rounded-circle me-4" width="42" alt="Profile photo">
			<span iu-name>${contact.name}</span>`,
  				'd-flex'
  			);
  			newUser.setPopover(
  				null,
  				e => {
  					contactsStorage.remove(newUserId);
  					contactsBody.update();
  				},
  				e => {
  					contactModal.show();
  				}
  			);
  			contactsStorage.add(newUser);
  			contactsBody.update();
  		});
  	}

  	return true
  })();

  const preloader = (() => {
  	window.onload = function () {
  		const preloader = document.querySelector('.page-loading');

  		if (window.screen.width < 992) {
  			preloader.querySelector('span').textContent = 'Для просмотра приложения, нужен экран большего размера';
  			preloader.querySelector('.page-spinner').style.display = 'none';

  			return
  		}

  		preloader.classList.remove('active');
  		setTimeout(function () {
  			preloader.remove();
  		}, 1000);
  	};

  	return true
  })();

  /**
   * Silicon | Multipurpose Bootstrap Template & UI Kit
   * Copyright 2022 Createx Studio
   * Theme core scripts
   *
   * @author Createx Studio
   * @version 1.3.0
   */

}());
